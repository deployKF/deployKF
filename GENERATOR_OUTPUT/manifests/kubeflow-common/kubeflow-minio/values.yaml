deployKF_helpers:
  kubeflow_gateway:
    http_endpoint: "kubeflow.example.com:8080"
    https_endpoint: "kubeflow.example.com:8443"
    is_self_signed_cert: "true"

deployKF:
  clusterDomain: cluster.local

  certManager:
    clusterIssuer:
      selfSigned:
        injectedConfigMapName: "kubeflow-gateway-issuer-root-ca-cert"

  auth:
    namespace: "kubeflow-auth"

  gateway:
    namespace: "kubeflow-istio-gateway"
    serviceAccount: "kubeflow-gateway"
    name: "kubeflow-gateway"
    hostname: "kubeflow.example.com"
    tls:
      enabled: true


########################################
## COMPONENT | minio
########################################
minio:
  ## configs for the minio container image
  ##
  image:
    repository: minio/minio
    tag: RELEASE.2023-02-17T17-52-43Z
    pullPolicy: IfNotPresent
    pullSecret: ""
    uid: 1000
    gid: 1000

  ## configs for the mc container image
  ##
  mcImage:
    repository: minio/mc
    tag: RELEASE.2023-02-16T19-20-11Z
    pullPolicy: IfNotPresent
    pullSecret: ""
    uid: 1000
    gid: 1000

  ## resource requests/limits for the minio Pods
  ## - spec for ResourceRequirements:
  ##   https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#resourcerequirements-v1-core
  ##
  resources: {}

  ## persistence configs for minio
  ##
  persistence:
    enabled: true

    ## the name of an existing PersistentVolumeClaim to use
    ## - if non-emtpy, you must manually create a PVC with this name
    ##
    existingClaim: ""

    ## the sub-path within the PersistentVolume to mount, instead of the root
    ##
    subPath: ""

    ## the name of the StorageClass requested by the PersistentVolumeClaim
    ## - if set to "", then `PersistentVolumeClaim/spec.storageClassName` is omitted
    ## - if set to "-", then `PersistentVolumeClaim/spec.storageClassName` is set to ""
    ##
    storageClass: ""

    ## the access mode of the PersistentVolumeClaim
    ##
    accessMode: ReadWriteOnce

    ## the initial size for the PersistentVolumeClaim to request
    ## - kubernetes allows the PVC to grow in size as needed, starting from this value
    ##   (if your StorageClass has `allowVolumeExpansion=true`)
    ##
    size: 5Gi

  ## root user configs for minio
  ##
  rootUser:
    username: "minioadmin"
    password: "minioadmin"
    existingSecret: ""
    existingSecretUsernameKey: "username"
    existingSecretPasswordKey: "password"

  ## identity configs for minio
  ##
  identity:
    ## OpenID configs for minio
    ##
    openid:
      ## TODO: explain how this can be set to "groups" when using LDAP/OAUTH as your dex connector
      policyClaim: "aud"

      clientId: "minio-console"
      ## TODO: we can remove the need to set these here by moving them into the auth chart, and replicating secrets
      clientSecret:
        ## TODO: we currently use hard-coded `value` environment variables in the deployment, use secret
        value: "bbbbbbbbbbbbbbbb"
        existingSecret: ""
        existingSecretKey: "client_secret"

  ## minio access policies to create with a post-install job
  ##
  policies:
    ## TODO: consider if we can use policy conditions to assign access based on email (all users are assigned `minio-console`)
    ##       https://min.io/docs/minio/linux/administration/identity-access-management/policy-based-access-control.html#supported-s3-policy-condition-keys
    - name: minio-console
      policy:
        version: "2012-10-17"
        statement:
          - effect: Allow
            action:
              - "admin:*"
          - effect: Allow
            action:
              - "kms:*"
          - effect: Allow
            action:
              - "s3:*"
            resource:
              - "arn:aws:s3:::*"

  ## minio buckets to create with a post-install job
  ##
  buckets:
    ## TODO: should we be taking the bucket name from kubeflow-pipelines value, or forcing user to align them?
    - name: "kubeflow-pipelines"
      versioning: false

  ## TODO: consider adding programmatic creation of access keys
  #accessKeys: []