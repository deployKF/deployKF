## TODO: decide if we want to include this, as this filter may not be necessary if we ensure all traffic comes from the istio gateway
##
################
## This EnvoyFilter verifies the JWT inside the "Authorization" header of incoming requests to Pods with the
## `deploykf.github.io/jwt-validate: "true"` label.
## ---
## This will NOT reject requests that have no "Authorization" header set.
## However, "FILTER 2" sets `envoy.filters.http.lua.jwt_validate[userid.is_valid]` dynamic metadata that we use with `where`
## conditions in `AuthorizationPolicy` to selectively apply JWT validation to HTTP paths for each Pod.
################
#apiVersion: networking.istio.io/v1alpha3
#kind: EnvoyFilter
#metadata:
#  name: deploykf-auth--jwt-validate
#  ## NOTE: this is in the root istio namespace, so that it can select pods across all namespaces
#  namespace: {{ .Values.deployKF.istio.namespace | quote }}
#  labels:
#    helm.sh/chart: {{ include "deploykf-auth.labels.chart" . }}
#    app.kubernetes.io/name: {{ include "deploykf-auth.labels.name" . }}
#    app.kubernetes.io/instance: {{ .Release.Name }}
#    app.kubernetes.io/managed-by: {{ .Release.Service }}
#    app.kubernetes.io/component: cluster-istio-configs
#spec:
#  workloadSelector:
#    labels:
#      deploykf.github.io/jwt-validate: "true"
#  configPatches:
#    ######################################################################
#    ## FILTER 1 - Validate JWT `authorization` header
#    ######################################################################
#    - applyTo: HTTP_FILTER
#      match:
#        context: SIDECAR_INBOUND
#        listener:
#          filterChain:
#            filter:
#              name: envoy.filters.network.http_connection_manager
#      patch:
#        ## insert as the FIRST http filter in the chain
#        operation: INSERT_FIRST
#        value:
#          name: envoy.filters.http.jwt_authn
#          typed_config:
#            ## https://www.envoyproxy.io/docs/envoy/v1.18.4/api-v3/extensions/filters/http/jwt_authn/v3/config.proto#extensions-filters-http-jwt-authn-v3-jwtauthentication
#            "@type": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication
#
#            ## a map of provider names to `extensions.filters.http.jwt_authn.v3.JwtProvider`
#            providers:
#              ## https://www.envoyproxy.io/docs/envoy/v1.18.4/api-v3/extensions/filters/http/jwt_authn/v3/config.proto#extensions-filters-http-jwt-authn-v3-jwtprovider
#              dex_provider:
#                ## the issuing principal, must match the `iss` field in the JWT
#                {{- if .Values.deployKF.gateway.tls.enabled }}
#                issuer: "https://{{ .Values.deployKF_helpers.deploykf_gateway.https_endpoint }}/dex"
#                {{- else }}
#                issuer: "http://{{ .Values.deployKF_helpers.deploykf_gateway.http_endpoint }}/dex"
#                {{- end }}
#
#                ## https://www.envoyproxy.io/docs/envoy/v1.18.4/api-v3/extensions/filters/http/jwt_authn/v3/config.proto#extensions-filters-http-jwt-authn-v3-remotejwks
#                remote_jwks:
#                  ## the HTTP URI to fetch the JWKS
#                  http_uri:
#                    uri: "http://dex.{{ .Release.Namespace }}.svc.{{ .Values.deployKF.clusterDomain }}:5556/dex/keys"
#                    cluster: "outbound|5556||dex.{{ .Release.Namespace }}.svc.{{ .Values.deployKF.clusterDomain }}"
#                    timeout: 5.00s
#
#                  ## duration after which the cached JWKS should be expired
#                  cache_duration: 300s
#
#                ## if `false`, the JWT is removed in the request after a success verification
#                ## (must be `true`, so `central-dashboard can relay user authentication to `kfam-api`)
#                forward: true
#
#                ## https://www.envoyproxy.io/docs/envoy/v1.18.4/api-v3/extensions/filters/http/jwt_authn/v3/config.proto#envoy-v3-api-msg-extensions-filters-http-jwt-authn-v3-jwtheader
#                from_headers:
#                  - name: "Authorization"
#                    value_prefix: "Bearer "
#
#                ## the verified JWT payload will be written to `streamInfo():dynamicMetadata():get("envoy.filters.http.jwt_authn")` under this key
#                payload_in_metadata: "jwt_payload"
#
#                ## the clock skew in seconds when verifying JWT time constraint, such as `exp`, and `nbf`
#                clock_skew_seconds: 60
#
#            ## requirements based on the route matches
#            ## https://www.envoyproxy.io/docs/envoy/v1.18.4/api-v3/extensions/filters/http/jwt_authn/v3/config.proto#envoy-v3-api-msg-extensions-filters-http-jwt-authn-v3-requirementrule
#            rules:
#              - match:
#                  prefix: /
#                requires:
#                  requires_any:
#                    requirements:
#                      - provider_name: dex_provider
#                      ## allow if request is missing JWT
#                      ## (we use dynamicMetadata outputs of "FILTER 2" with AuthorizationPolicies to restrict which paths can be missing)
#                      - allow_missing: {}
#
#    ######################################################################
#    ## FILTER 2 - Check if USERID header equals JWT "email" claim
#    ## (NOTE: this filter sets the `envoy.filters.http.lua.jwt_validate[userid.is_valid]` flag)
#    ######################################################################
#    - applyTo: HTTP_FILTER
#      match:
#        context: SIDECAR_INBOUND
#        listener:
#          filterChain:
#            filter:
#              name: envoy.filters.network.http_connection_manager
#              subFilter:
#                name: envoy.filters.http.jwt_authn
#      patch:
#        ## insert our filter right AFTER our `envoy.filters.http.jwt_authn` filter
#        operation: INSERT_AFTER
#        value:
#          name: envoy.filters.http.lua.jwt_validate
#          typed_config:
#            ## https://www.envoyproxy.io/docs/envoy/v1.18.4/api-v3/extensions/filters/http/lua/v3/lua.proto
#            "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
#
#            ## https://www.envoyproxy.io/docs/envoy/v1.18.4/configuration/http/http_filters/lua_filter#config-http-filters-lua
#            inline_code: |
#              function respond_403(request_handle)
#                request_handle:respond(
#                  {[":status"] = "403"},
#                  "JWT Failure"
#                )
#              end
#
#              function envoy_on_request(request_handle)
#                local userid_header = request_handle:headers():get({{ .Values.deployKF.kubeflow.useridHeader | quote }})
#
#                -- only check `userid_header` if it's set
#                if (userid_header ~= nil) then
#
#                  -- get metdata from "envoy.filters.http.jwt_authn" filter
#                  local jwt_metadata = request_handle:streamInfo():dynamicMetadata():get("envoy.filters.http.jwt_authn")
#                  if (jwt_metadata == nil) then
#                    respond_403(request_handle)
#                  end
#
#                  -- extract the verified JWT payload
#                  local jwt_payload = jwt_metadata["jwt_payload"]
#                  if (jwt_payload == nil) then
#                    respond_403(request_handle)
#                  end
#
#                  -- extract the "email" claim from the JWT payload
#                  local jwt_email = jwt_payload["email"]
#                  if (jwt_email == nil or jwt_email == "") then
#                    respond_403(request_handle)
#                  end
#
#                  -- set metadata flag indicating if `userid_header` equals `jwt_email`
#                  if (userid_header == jwt_email) then
#                    request_handle:streamInfo():dynamicMetadata():set(
#                      "envoy.filters.http.lua.jwt_validate",
#                      "userid.is_valid",
#                      "true"
#                    )
#                  else
#                    request_handle:streamInfo():dynamicMetadata():set(
#                      "envoy.filters.http.lua.jwt_validate",
#                      "userid.is_valid",
#                      "false"
#                    )
#                  end
#
#                end
#
#              end