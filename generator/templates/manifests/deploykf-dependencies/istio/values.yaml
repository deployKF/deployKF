global:
  istioNamespace: {{< .Values.deploykf_dependencies.istio.namespace | quote >}}

  #imagePullPolicy: IfNotPresent
  #imagePullSecrets: []
  #hub: docker.io/istio
  #tag: latest
  #proxy:
  #  image: proxyv2
  #  clusterDomain: cluster.local
  #proxy_init:
  #  image: proxyv2


## we reference the "base" chart (https://istio-release.storage.googleapis.com/charts) in `dependencies` of Chart.yaml,
## with an alias of "istio-base", so we must indent the values for "base" under `istio-base`
istio-base: {}


## we reference the "istiod" chart (https://istio-release.storage.googleapis.com/charts) in `dependencies` of Chart.yaml,
## with an alias of "istio-discovery", so we must indent the values for "istiod" under `istio-discovery`
istio-discovery:
  pilot:
    #hub: docker.io/istio
    #tag: latest
    #image: pilot

  sidecarInjectorWebhook:
    enableNamespacesByDefault: false
    #injectedAnnotations:
    #  cluster-autoscaler.kubernetes.io/safe-to-evict: "true"

  meshConfig:
    trustDomain: cluster.local
    #enablePrometheusMerge: true

    ## TODO: disable after development (as it prints all istio access logs to STDOUT)
    accessLogFile: /dev/stdout

    defaultConfig:
      proxyMetadata:
        ## these configs enable the istio "DNS Proxying" feature
        ##
        ## we use this feature to allow Pods in the mesh to access the deploykf-istio-gateway without the traffic
        ## leaving the mesh, this is achieved by creating a ServiceEntry for the gateway with its public DNS name,
        ## causing istio to intercept traffic to the gateway and route it directly to the gateway Pods
        ISTIO_META_DNS_CAPTURE: "true"
        ISTIO_META_DNS_AUTO_ALLOCATE: "true"

      ## this important config prevents race conditions between application containers and their injected sidecars
      ##
      ## that is, if an application starts before its sidecar, things might break:
      ## - example 1: the application successfully connects to an external service (like a MySQL database),
      ##   but once the sidecar begins intercepting all TCP traffic, the sidecar drops the connection or
      ##   fails to translate the already open TCP socket, causing the application to misbehave
      ## - example 2: the application attempts to access the gateway via a hostname which is not actually resolvable
      ##   on the cluster's DNS, for example, when we use the istio "DNS Proxying" feature to expose the gateway within
      ##   the mesh at deploykf.example.com, which we do not control on the public internet, so is unlikely
      ##   to successfully resolve on the cluster's DNS
      holdApplicationUntilProxyStarts: true