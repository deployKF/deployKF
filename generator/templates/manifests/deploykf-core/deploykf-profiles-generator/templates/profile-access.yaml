{{- /* build a dictionary for looking up users by id: {"user_id": user_object} */ -}}
{{- $users_id_mapping := dict }}
{{- range $index, $user := .Values.users }}
  {{- if $user.id }}
    {{- if hasKey $users_id_mapping $user.id }}
      {{- fail (printf "elements of `users` must have unique `id`, but '%s' appears more than once" $user.id) }}
    {{- else }}
      {{- /* verify this user's `email` */ -}}
      {{- if not $user.email }}
        {{- fail (printf "elements of `users` must have non-empty `email`, but element %d (user id: '%s') does not" $index $user.id) }}
      {{- end }}

      {{- /* cast `email` to lowercase, if applicable */ -}}
      {{- if $.Values.deployKF.gateway.emailToLowercase }}
      {{- $_ := set $user "email" ($user.email | lower) }}
      {{- end }}

      {{- /* store in users_id_mapping */ -}}
      {{- $_ := set $users_id_mapping $user.id $user }}
    {{- end }}
  {{- else }}
    {{- fail (printf "elements of `users` must have non-empty `id`, but element %d does not" $index) }}
  {{- end }}
{{- end }}

{{- /* build a dictionary for looking up groups by id: {"group_id": {"user_id": user_object}} */ -}}
{{- $group_id_mapping := dict }}
{{- range $group_index, $group := .Values.groups }}
  {{- if $group.id }}
    {{- if hasKey $group_id_mapping $group.id }}
      {{- fail (printf "elements of `groups` must have unique `id`, but '%s' appears more than once" $group.id) }}
    {{- else }}
      {{- /* get the user objects for each user in this group */ -}}
      {{- $group_users := dict }}
      {{ range $group_user_index, $group_user_id := $group.users | default list | uniq }}
        {{- if hasKey $users_id_mapping $group_user_id }}
          {{- $group_user := get $users_id_mapping $group_user_id }}
          {{- $_ := set $group_users $group_user_id $group_user }}
        {{- else }}
          {{- fail (printf "elements of `groups[%d].users` (group id: '%s') may only reference user IDs that exist in `users`, but element %d references '%s' which does not exist" $group_index $group.id $group_user_index $group_user_id) }}
        {{- end }}
      {{- end }}
      {{- /* store in group_id_mapping */ -}}
      {{- $_ := set $group_id_mapping $group.id $group_users }}
    {{- end }}
  {{- else }}
    {{- fail (printf "elements of `groups` must have non-empty `id`, but element %d does not" $group_index) }}
  {{- end }}
{{- end }}

{{- /* ------------------ */ -}}
{{- /* loop over profiles */ -}}
{{- /* ------------------ */ -}}
{{- range $profile_index, $profile := .Values.profiles }}
{{- $profile_name := printf "%s%s" $.Values.profileDefaults.profileNamePrefix $profile.name }}

{{- /* build a dictionary containing the access for each user: {"user_id": {"role": ..., "notebookAccess": ...}} */ -}}
{{- $user_access_mapping := dict }}
{{- range $member_index, $member := $profile.members }}
  {{- $member_access := $member.access | default dict | mergeOverwrite $.Values.profileDefaults.memberAccess }}

  {{- /* verify this member's `access.role` */ -}}
  {{- if not (has $member_access.role (list "view" "edit")) }}
    {{- fail (printf "elements of `profile[%d].members` (profile name: '%s') may only set `role` to 'view' or 'edit', but element %d sets '%s'" $profile_index $profile.name $member_index $member_access.role) }}
  {{- end }}

  {{- /*  verify this member's `access.notebooksAccess` */ -}}
  {{- if not (has $member_access.notebooksAccess (list true false)) }}
    {{- fail (printf "elements of `profile[%d].members` (profile name: '%s') may only set `notebooksAccess` to true or false, but element %d sets '%s'" $profile_index $profile.name $member_index $member_access.notebooksAccess) }}
  {{- end }}

  {{- /* unpack this member's `user` or `group` */ -}}
  {{- if and $member.user $member.group }}
    {{- fail (printf "elements of `profile[%d].members` (profile name: '%s') may set EITHER `user` or `group`, but element %d sets both" $profile_index $profile.name $member_index) }}
  {{- else if $member.group }}
    {{- /* CASE 1: `group` is specified */ -}}
    {{- if hasKey $group_id_mapping $member.group }}
      {{- $group_users := get $group_id_mapping $member.group }}
      {{- range $user_id, $_ := $group_users }}
        {{- if hasKey $user_access_mapping $user_id }}
          {{- $existing_access := get $user_access_mapping $user_id }}

          {{- /* upgrade `role` to 'edit', if applicable */ -}}
          {{- if and (eq $existing_access.role "view") (eq $member_access.role "edit") }}
            {{- $_ := set $existing_access "role" "edit" }}
          {{- end }}

          {{- /* upgrade `notebookAccess` to true, if applicable */ -}}
          {{- if and (eq $existing_access.notebooksAccess false) (eq $member_access.notebooksAccess true) }}
            {{- $_ := set $existing_access "notebooksAccess" true }}
          {{- end }}
        {{- else }}
          {{- $_ := set $user_access_mapping $user_id ($member_access | deepCopy) }}
        {{- end }}
      {{- end }}
    {{- else }}
      {{- fail (printf "elements of `profile[%d].members` (profile name: '%s') may only reference groups that exist in `groups`, but element %d references '%s' which does not exist" $profile_index $profile.name $member_index $member.group) }}
    {{- end }}
  {{- else if $member.user }}
    {{- /* CASE 2: `user` is specified */ -}}
    {{- if hasKey $users_id_mapping $member.user }}
      {{- $user_id := $member.user }}
      {{- if hasKey $user_access_mapping $user_id }}
        {{- $existing_access := get $user_access_mapping $user_id }}

        {{- /* upgrade `role` to 'edit', if applicable */ -}}
        {{- if and (eq $existing_access.role "view") (eq $member_access.role "edit") }}
          {{- $_ := set $existing_access "role" "edit" }}
        {{- end }}

        {{- /* upgrade `notebookAccess` to true, if applicable */ -}}
        {{- if and (eq $existing_access.notebooksAccess false) (eq $member_access.notebooksAccess true) }}
          {{- $_ := set $existing_access "notebooksAccess" true }}
        {{- end }}
      {{- else }}
        {{- $_ := set $user_access_mapping $user_id ($member_access | deepCopy) }}
      {{- end }}
    {{ end }}
  {{- else }}
    {{- fail (printf "elements of `profile[%d].members` (profile name: '%s') must set `user` OR `group`, but element %d sets neither" $profile_index $profile.name $member_index)}}
  {{ end }}
{{- end }}

{{- /* ------------------------------------------ */ -}}
{{- /* loop over users with access to the profile */ -}}
{{- /* ------------------------------------------ */ -}}
{{- range $user_id, $user_access := $user_access_mapping }}

{{- /* get the user object */ -}}
{{- $user := get $users_id_mapping $user_id }}

{{- /*
calculate the Kubernetes resource name base:
 - Kubeflow generates the `AuthorizationPolicy` and `RoleBinding` resource names from the
   user's email by replacing any special characters with '-' and casting to lower-case
*/}}
{{- $resource_name := regexReplaceAll "[^0-9a-zA-Z]" $user.email "-" | lower }}

{{- if $user_access.notebooksAccess }}
---
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: user-{{ $resource_name }}-clusterrole-{{ $user_access.role }}
  namespace: {{ $profile_name | quote }}
  annotations:
    role: {{ $user_access.role | quote }}
    user: {{ $user.email | quote }}
  labels:
    helm.sh/chart: {{ include "deploykf-profiles-generator.labels.chart" $ }}
    app.kubernetes.io/name: {{ include "deploykf-profiles-generator.labels.name" $ }}
    app.kubernetes.io/instance: {{ $.Release.Name }}
    app.kubernetes.io/managed-by: {{ $.Release.Service }}
spec:
  rules:
    ## allow requests from `deploykf-istio-gateway` Pods with this user's email in the `useridHeader`
    - from:
        - source:
            principals:
              - "{{ $.Values.deployKF.clusterDomain }}/ns/{{ $.Values.deployKF.gateway.namespace }}/sa/{{ $.Values.deployKF.gateway.serviceAccount }}"
              {{- if $.Values.deployKF.kubeflow.pipelines.enabled }}
              ## the `ml-pipeline-ui` pod will proxy some requests into the user's namespace,
              ## for example, to view logs on the object store
              - "{{ $.Values.deployKF.clusterDomain }}/ns/{{ $.Values.deployKF.kubeflow.pipelines.pipelineUI.namespace }}/sa/{{ $.Values.deployKF.kubeflow.pipelines.pipelineUI.serviceAccount }}"
              {{- end }}
      when:
        - key: request.headers[{{ $.Values.deployKF.kubeflow.useridHeader }}]
          values:
            - {{ $user.email | quote }}
{{- end }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: user-{{ $resource_name }}-clusterrole-{{ $user_access.role }}
  namespace: {{ $profile_name | quote }}
  annotations:
    role: {{ $user_access.role | quote }}
    user: {{ $user.email | quote }}
  labels:
    helm.sh/chart: {{ include "deploykf-profiles-generator.labels.chart" $ }}
    app.kubernetes.io/name: {{ include "deploykf-profiles-generator.labels.name" $ }}
    app.kubernetes.io/instance: {{ $.Release.Name }}
    app.kubernetes.io/managed-by: {{ $.Release.Service }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kubeflow-{{ $user_access.role }}
subjects:
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: {{ $user.email | quote }}
{{- end }}
{{- end }}