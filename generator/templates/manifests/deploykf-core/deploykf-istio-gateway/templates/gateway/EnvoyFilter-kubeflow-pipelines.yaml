{{- if and .Values.deployKF.kubeflow.pipelines.enabled (.Values.deployKF.argoWorkflows.artifactRepository.keyFormat | hasPrefix "artifacts/{{ workflow.namespace }}/") }}
################
## This EnvoyFilter redirects artifact requests that use an incorrect `?namespace=` query parameter for an artifact.
## This is required because bucket IAM policies restrict bucket access based on the namespace prefix.
## NOTE: Kubeflow Pipelines will sometimes use an artifact which was cached by another namespace.
## NOTE: the user might still not have access after the redirect if they are not a member of the correct namespace.
################
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: deploykf-istio-gateway--kubeflow-pipelines-redirect-artifact-namespaces
  labels:
    helm.sh/chart: {{ include "deploykf-istio-gateway.labels.chart" . }}
    app.kubernetes.io/name: {{ include "deploykf-istio-gateway.labels.name" . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  workloadSelector:
    labels:
      {{- toYaml .Values.deployKF.gateway.selectorLabels | nindent 6 }}
  configPatches:
    ################################################################################
    ## FILTER 1 - Empty global lua filter (needed to allow per-route lua filter)
    ################################################################################
    - applyTo: HTTP_FILTER
      match:
        context: GATEWAY
        listener:
          filterChain:
            filter:
              name: envoy.filters.network.http_connection_manager
              subFilter:
                ## the Lua filter that sets USERID_HEADER is called "envoy.filters.http.lua.set_userid_header"
                name: envoy.filters.http.lua.set_userid_header
      patch:
        operation: INSERT_AFTER
        value:
          name: envoy.filters.http.lua.kfp_redirect_artifact_namespaces
          typed_config:
            ## https://www.envoyproxy.io/docs/envoy/v1.18.4/api-v3/extensions/filters/http/lua/v3/lua.proto
            "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua

            ## https://www.envoyproxy.io/docs/envoy/v1.18.4/configuration/http/http_filters/lua_filter#config-http-filters-lua
            inlineCode: |
              function envoy_on_request(request_handle)
                -- empty lua function
              end

    ################################################################################
    ## PATCH - Enable lua filter for the `ml-pipeline-ui-artifacts-route`
    ################################################################################
    - applyTo: HTTP_ROUTE
      match:
        context: GATEWAY
        routeConfiguration:
          vhost:
            route:
              ## HTTP route names are specified in VirtualServices
              name: ml-pipeline-ui-artifacts-route
      patch:
        operation: MERGE
        value:
          typed_per_filter_config:
            envoy.filters.http.lua.kfp_redirect_artifact_namespaces:
              ## https://www.envoyproxy.io/docs/envoy/v1.18.4/api-v3/extensions/filters/http/lua/v3/lua.proto#extensions-filters-http-lua-v3-luaperroute
              "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.LuaPerRoute

              ## https://www.envoyproxy.io/docs/envoy/v1.18.4/configuration/http/http_filters/lua_filter#config-http-filters-lua
              source_code:
                inline_string: |
                  function extract_url_namespaces(url_path)
                      -- extract namespace from object key
                      local key_namespace
                      if url_path:match("^/pipeline/artifacts/get") then
                          -- FORMAT: "/pipeline/artifacts/get...&key=artifacts%2F<key_namespace>%2F..."
                          key_namespace = url_path:match("[?&]key=artifacts%%2F([^%%]+)%%2F")
                      else
                          -- FORMAT: "/pipeline/artifacts/<object_store>/<bucket>/artifacts/<key_namespace>/..."
                          key_namespace = url_path:match("^/pipeline/artifacts/[^/?&]+/[^/?&]+/artifacts/([^/?&]+)/")
                      end

                      -- extract namespace from query, if key_namespace is not nil
                      local query_namespace
                      if key_namespace then
                          -- FORMAT: "/pipeline/artifacts/...&namespace=<query_namespace>..."
                          query_namespace = url_path:match("[?&]namespace=([^&]*)")
                      end

                      return key_namespace, query_namespace
                  end

                  function envoy_on_request(request_handle)
                      local url_path = request_handle:headers():get(":path")
                      local key_namespace, query_namespace = extract_url_namespaces(url_path)

                      -- if key and query namespaces do not match, redirect with updated query_namespace
                      if key_namespace and query_namespace and key_namespace ~= query_namespace then
                          local match_str = "([?&])namespace=[^?&]*"
                          local replace_str = "%1namespace=" .. key_namespace
                          local new_url_path = url_path:gsub(match_str, replace_str)
                          request_handle:respond(
                                  { [":status"] = "302", ["location"] = new_url_path },
                                  "Redirecting to correct namespace..."
                          )
                      end
                  end
{{- end }}